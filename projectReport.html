<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>MSAN 622 Information Visualization</title>

<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/bootstrap-theme.min.css" rel="stylesheet">

<style type="text/css">
    body {
        padding-top: 50px;
        padding-bottom: 20px;
    }
    svg {
    background-color: white;
    margin: 1px;
    float: left;
    }

    /*dashboard{*/
    /*padding-top: 100px;*/
    /*}*/
    /*#dashboard{*/
    /*width: 1050px;*/
    /*height: 800px;*/
    /*overflow: scroll;*/
/*}*/
.tooltip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 4px;
    white-space: nowrap;
}
/*.tooltip:after {*/
  /*box-sizing: border-box;*/
  /*display: inline;*/
  /*font-size: 10px;*/
  /*width: 100%;*/
  /*line-height: 1;*/
  /*color: rgba(0, 0, 0, 0.8);*/
  /*content: "\25BC";*/
  /*position: absolute;*/
  /*text-align: center;*/
/*}*/

/* Style northward tooltips differently */
.tooltip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
/*.tooltip {*/
    /*box-sizing: border-box;*/
    /*display: inline;*/
    /*line-height: 1;*/
    /*font-weight: bold;*/
    /*display: inline;*/
    /*padding: 12px;*/
    /*width: 100%;*/
    /*height:100%;*/

  /*background: rgba(0, 0, 0, 0.8);*/
  /*color: #fff;*/
  /*border-radius: 2px;*/
    /*}*/
</style>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<![endif]-->
</head>

<body>

<!-- Fixed Navbar -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../index.html">MSAN 622</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="#homework">Homework</a></li>
                <li><a href="#project">Project</a></li>
                <li><a href="#participation">Participation</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div>
</nav>

<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>

<div class="container">
<div id = "dashboard2">
<script>
var framewidth2 = 1400,
    frameheight2 = 800;
    radius = 105;

var color = d3.scale.linear().range(["#ef8a62","#67a9cf"]).domain([0,24]);

var arc = d3.svg.arc()
    .outerRadius(radius *.6)
    .innerRadius(radius *.4);

var outerArc = d3.svg.arc()
	    .innerRadius(radius * 0.7)
	    .outerRadius(radius * 0.7);

var margin2 = {"left":50,"top":50,"right":50,"bottom":50};

var hour = [];
var hour2 = ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17","18","19","20","21","22","23"];
var date2 = ["01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30"];
for ( var i = 0 ; i<24 ;i++){ hour.push({"label":i,"value":1})}
var date = [];
for ( var j = 0 ; j<30 ;j++){ date.push({"label":j,"value":1})}

var pie = d3.layout.pie()
    .sort(null)
    .value(function(d) { return d.value; });

var dashboard2 = d3.select("#dashboard2").append("svg")
        .attr("width", framewidth2)
        .attr("height", frameheight2);

var widget = dashboard2.append("g").attr("transform", "translate(" + (margin2.left) + "," + (margin2.top) + ")");

var calender = widget.append("g");

var gridSize = radius*2/7;

var selectDate = 1;
var selectHour = 15;
var file = "./data/bikeshare/bs_2012_11_".concat(date2[0] + ".csv");

// initiate the calendar heat map
var calmap = calender.append("g");

  calmap.selectAll(".rect").data(date).enter().append("rect")
        .attr("x", function(d,i) { return ((i+4)%7)* gridSize; })
        .attr("y", function(d,i){ return Math.floor((i+4)/7)*gridSize})
        .attr("rx", 3)
        .attr("ry", 3)
        .attr("id", function(d){ return "rect" + (+d.label+1);})
        .attr("width", gridSize*0.9)
        .attr("height", gridSize*0.9)
        .style("fill", function(d){ return x = (+d.label+1 === selectDate) ? "gray" : "silver"}).style("stroke","white")
        .on("mouseover", function(d){ d3.select(this).style("stroke","gray") ;})
        .on("mouseout", function(d){d3.select(this).style("stroke","white") ;})
        .on("click", function(d){

            d3.select(this).style("fill","gray");
            selectDate_ = "#rect" + selectDate;
            console.log(selectDate_);
            d3.select(selectDate_).transition().duration(300).style("fill","silver");
            selectDate = +d.label+1;

            // selected file change
            file = "./data/bikeshare/bs_2012_11_".concat(date2[+d.label] + ".csv");

//            d3.selectAll(".station").remove();

//            plotCircle();
            updateCal(file);

        });


var days = ["Sun","Mon","Tue","Wed","Thur","Fri","Sat"];
var daysText = calender.append("g");
    daysText.selectAll(".days").data(days).enter().append("text").attr("x", function(d,i) { return (i+0.5) * gridSize; }).attr("y", -5)
                    .text(function(d){return d;}).style({"font-size":10,"text-anchor":"middle","font-family":"georgia, serif","font-weight":"bold"});

var dateText = calender.append("g");
    dateText.selectAll(".date").data(date).enter().append("text")
            .attr("x", function(d,i) { return ( ((i+4)%7) + 0.5)* gridSize; })
            .attr("y", function(d,i){ return (Math.floor((i+4)/7) + 0.5)*gridSize})
            .text(function(d){return (+d.label+1);}).style({"font-size":10,"text-anchor":"middle","font-family":"georgia, serif","font-weight":"bold"});

var donutChart = widget.append("g").attr("transform", "translate(" + radius + "," + (radius + gridSize*5) + ")");


// initial the clock donut chart
var donut = donutChart.selectAll(".arc")
        .data(pie(hour))
        .enter().append("g")
        .attr("class", "arc");


    donut.append("path")
            .attr("d", arc)
            .style("fill", function(d) { return color(d.data.label)}).style({"stroke":"white","stroke-width":"1"})
            .on("mouseover", function(d){
                d3.select(this).style("opacity",0.5);
            })
            .on("mouseout", function(d){
                d3.select(this).style("opacity",1);
            })
            .on("click", function(d){
                console.log(d);
                selectHour = +d.data.label;
                selectHourText.transition().duration(1000).style("fill","gray");

                updateClock(+d.data.label);


                selectHourText = d3.select("#hourText"+selectHour);
                selectHourText.style("fill","#fb8072");

                });


    donut.append("text")
      .attr("transform", function(d) { return "translate(" + outerArc.centroid(d) + ")"; })
      .attr("dy", ".35em")
      .attr("id", function(d){ return "hourText"+d.data.label;})
      .style("text-anchor", "middle")
      .text(function(d) { return d.data.label; })
            .style("fill",function(d){return (d.data.label === selectHour) ? "#fb8072" : "gray";})
            .style("font-size",14);

var selectHourText = d3.select("#hourText15");
//      .style("fill",function(d){ return fill = (d.data.label===selectHour)? "black" : "gray";});
//            .style("font-size",function(d){ return fontsize = (d.data.label===selectHour)? 16 : 12;});

var starthour = 15;

var width2 = 250;
var height2 = 100;

var xScale1 = d3.time.scale().range([0, width2]),
    yScale1 = d3.scale.linear().range([height2, 0]);

var xAxis1 = d3.svg.axis().scale(xScale1).orient("bottom").ticks(3),
    yAxis1 = d3.svg.axis().scale(yScale1).orient("left").ticks(3);

var line1 = d3.svg.line()
    .interpolate("cardinal") // smoothing method
    .x(function(d) { return xScale1(d.hour); })
    .y(function(d) { return yScale1(d["net"]); });

var parseDate = d3.time.format("%Y-%m-%d %H:%M:%S").parse;
var parseDate2 = d3.time.format("%H").parse;
var temperatureHeight = 100;
var lineChart1 = dashboard2.append("g").attr("transform", "translate(" + margin2.left + "," + (margin2.top + radius*2 + gridSize*5 + temperatureHeight) +")");
var dcmap = dashboard2.append("g").attr("transform", "translate(" + 500 + "," + margin2.top +")");


function compare(a,b) {
  if (a.hour < b.hour)
     return -1;
  if (a.hour > b.hour)
    return 1;
  return 0;
}
var lineChartLegend = ["steelblue","black"];
var legend = lineChart1.selectAll(".legend")
      .data(lineChartLegend)
    .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(0," + (1+(i+2)/5)*height2 + ")"; });

var legendline = legend.append("line")
      .attr("x1", 5)
      .attr("y1", 0)
      .attr("x2", 15)
        .style("stroke",function(d){return d;})
        .style({"fill":"none","stroke-width":2});



var linevalues0 = null;
var linevalues1 = null;
var linedata = null;

// initial line chart
var station0 = "10th & E St NW";
var station1 = "16th & Harvard St NW";

d3.csv("./data/bikeshare/bs_2012_11_01.csv",

        function(d){

            return {
                    "hour": parseDate2(d.hour),
                    "net": +d.net,
                    "station": d.station,
                    "lat" : +d.lat,
                    "lon" : +d.lon,
                    "zipcode" : d.postal_code};},

        function(error,data){

            console.log(error);

            // initiate data for linechart
            var data_ = [];
            var data2_ = [];

            data.forEach(function(d){
                if (d.station === station0){  data_.push(d);}
                if (d.station === station1){ data2_.push(d);}

            });

            data_.sort(compare);
            data2_.sort(compare);

            plotLineChart.values0(data_);
            plotLineChart.values1(data2_);
            plotLineChart.data(data);
            plotLineChart();






        });
function plotLineChart() {




    xScale1.domain(d3.extent(linedata.map(function (d) {return d.hour;}))).ticks(4);

    yScale1.domain(d3.extent(linedata.map(function (d) {return d["net"];})));

    var xGuide1 = lineChart1.append("g")
            .attr("class","x axis")
            .attr("id","lineChartxAxis")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis1);

    xGuide1.select("path").style({"fill": "none", "stroke": "black"});
    xGuide1.selectAll("line").style({"fill": "none"});

    var yGuide1 = lineChart1.append("g")
            .attr("id","lineChartyAxis")
            .attr("class", "y axis")
            .call(yAxis1);

    yGuide1.select("path").style({"fill": "none", "stroke": "black"});
    yGuide1.selectAll("line").style({"fill": "none"});
    yGuide1.append("text").text("Bike Demand").style("text-anchor", "middle").attr("y", -10);


    lineChart1.append("path")
            .datum(linevalues0).attr("id", "line0").attr("d", line1).style({
                "fill": "none",
                "stroke": "steelblue",
                "stroke-width": 2
            });


    lineChart1.append("path")
            .datum(linevalues1).attr("id", "line1").attr("d", line1).style({
                "fill": "none",
                "stroke": "black",
                "stroke-width": 2
            });


    legend.data([linevalues0[0]["station"], linevalues1[0]["station"]]).append("text").attr("id", function (d, i) {
        return "linelegendlabel" + i;})
            .attr("transform","translate(140,0)")
            .attr("x", 0)
            .attr("y", 0)
            .attr("dy", ".35em")
            .text(function (d) {
                return  d;
            });

    legend.data([linevalues0[0]["net"], linevalues1[0]["net"]]).append("text").attr("id", function (d, i) {
        return "linelegendBikeNumber" + i;
    })
            .attr("x", 20)
            .attr("y", 0)
            .attr("dy", ".35em")
            .text(function (d) {
                return "Bike Demand: " + d;
            });



    var focus = lineChart1.append("g")
            .style("display", "none");

    // append the x line
    focus.append("line")
            .attr("id", "linetipx")
            .style("stroke", "blue")
            .style("stroke-dasharray", "3,3")
            .style("opacity", 0.5)
            .attr("y1", 0)
            .attr("y2", height2);

    // append the y line0
    focus.append("line")
            .attr("id", "linetipy0")
            .style("stroke", "blue")
            .style("stroke-dasharray", "3,3")
            .style("opacity", 0.5)
            .attr("x1", width2)
            .attr("x2", width2);

    // append the y line1
    focus.append("line")
            .attr("id", "linetipy1")
            .style("stroke", "black")
            .style("stroke-dasharray", "3,3")
            .style("opacity", 0.5)
            .attr("x1", width2)
            .attr("x2", width2);

    // circle 1
    focus.append("circle")
            .attr("id", "linetip0")
            .style("fill", "none")
            .style("stroke", "steelblue")
            .attr("r", 4);

    // circle 2
    focus.append("circle")
            .attr("id", "linetip1")
            .style("fill", "none")
            .style("stroke", "black")
            .attr("r", 4);

    // append hour text
    focus.append("text")
        .attr("id", "hourtip")
//        .style("stroke", "white")
        .style("stroke-width", "3.5px")
        .style("opacity", 0.8)
        .attr("dx", 8)
        .attr("dy", "-.5em");
//    focus.append("text")
//        .attr("class", "y2")
//        .attr("dx", 8)
//        .attr("dy", "-.3em");


    lineChart1.append("rect")
            .attr("width", width2)
            .attr("height", height2)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mouseover", function () {
                focus.style("display", null);
            })
            .on("mouseout", function () {
                focus.style("display", "none");
            })
            .on("mousemove", mousemove);

    var bisectDate = d3.bisector(function (d) {
        return d.hour;
    }).left;

    function mousemove() {

        var x0 = xScale1.invert(d3.mouse(this)[0]),
                i = bisectDate(linevalues0, x0, 1),
                d0 = linevalues0[i - 1],
                d1 = linevalues0[i],
                d = x0 - d0.hour > d1.hour - x0 ? d1 : d0,

                d0_ = linevalues1[i - 1],
                d1_ = linevalues1[i],
                d_ = x0 - d0_.hour > d1_.hour - x0 ? d1_ : d0_;

        focus.select("#linetip0")
                .attr("transform",
                "translate(" + xScale1(d.hour) + "," +
                yScale1(d.net) + ")");

        focus.select("#linetip1")
                .attr("transform",
                "translate(" + xScale1(d_.hour) + "," +
                yScale1(d_.net) + ")");

        var tempheight = d.net > d_.net ? d.net : d_.net;

        focus.select("#linetipx")
                .attr("transform",
                "translate(" + xScale1(d.hour) + "," +
                yScale1(tempheight) + ")")
                .attr("y2", height2 - yScale1(tempheight));

        focus.select("#linetipy0")
                .attr("transform",
                "translate(0," + yScale1(d.net) + ")").attr("x2",0);

        focus.select("#linetipy1")
                .attr("transform",
                "translate(0," + yScale1(d_.net) + ")").attr("x2",0);

        console.log(d);
        focus.select("#hourtip").attr("transform",
                "translate(" + xScale1(d.hour) + "," +
                yScale1(tempheight) + ")").text(d.hour.getHours() +":00");

        d3.select("#linelegendBikeNumber0").transition().duration(1000).text("Bike Demand: " + d.net);
        d3.select("#linelegendBikeNumber1").transition().duration(1000).text("Bike Demand: " + d_.net);
    }

}

// updates the symbols values, must happen before drawing
var missStation = hour2.map(function(d){return 0;});
plotLineChart.values0 = function(_) {
        if (!arguments.length) {return linevalues0;}
        linevalues0 = _;
        return plotLineChart;
        };
plotLineChart.values1 = function(_) {
        if (!arguments.length) {return linevalues1;}
        linevalues1 = _;
        return plotLineChart;
        };
plotLineChart.data = function(_) {
        if (!arguments.length) {return linedata;}
        linedata = _;
        return plotLineChart;
        };
plotLineChart.update1 = function(){

    var data_ = [];
    var data2_ = [];

    linedata.forEach(function (d) {
        if (d.station === station0) {data_.push(d);}
        if (d.station === station1){ data2_.push(d);}
    });

    // if miss station0 or 1
    if ( data_.length < 24){ data_ = missStation;}
    if ( data2_.length < 24){ data2_ = missStation;}

    data_.sort(compare);
    data2_.sort(compare);
//    console.log(data_);
//    console.log(data2_);
    plotLineChart.values0(data_);
    plotLineChart.values1(data2_);
    d3.select("#line0").datum(linevalues0).transition().duration(1000).attr("d", line1);
    d3.select("#line1").datum(linevalues1).transition().duration(1000).attr("d", line1);

    //update line chart
};
plotLineChart.updateAxis = function(){


    xScale1.domain(d3.extent(linedata.map(function (d) {return d.hour;}))).ticks(4);
    yScale1.domain(d3.extent(linedata.map(function (d) {return d["net"];})));
//    console.log(yScale1.domain());
    yAxis1.scale(yScale1);
    d3.select("#lineChartyAxis").transition().duration(1000).call(yAxis1);
    var yGuide_ = d3.select("#lineChartyAxis");
    yGuide_.selectAll('line').style({"fill": "none", "stroke": "black"});
    yGuide_.selectAll('path').style({"fill": "none", "stroke": "black"});

};

var lineCount = 0; // for selecting the line chart
function updatelineChart(station, net){


    d3.csv(file,

        function(d){

                return {
                    "hour": parseDate2(d.hour),
                    "net": +d.net,
                    "station": d.station,
                    "lat" : +d.lat,
                    "lon" : +d.lon,
                    "zipcode" : d.postal_code};},

        function(error,data) {


            var data_ = [];

            data.forEach(function (d) {
                if (d.station === station) {
                    data_.push(d);
                }
            });
            data_.sort(compare);

            if (lineCount%2 === 0){
                plotLineChart.values0(data_);
                d3.select("#line0").datum(linevalues0).transition().duration(1000).attr("d", line1);
                d3.select("#linelegendlabel0").transition().duration(1000).text(station);
                station0 = station;
            }
            else{
                plotLineChart.values1(data_);
                d3.select("#line1").datum(linevalues1).transition().duration(1000).attr("d", line1);
                d3.select("#linelegendlabel1").transition().duration(1000).text(station);
                station1 = station;
            }
            lineCount++;


        })


}



//initiate the map
var projection = d3.geo.mercator().center([-77.0164,38.9047]).scale(120000).rotate([0,0,0]);
var path = d3.geo.path().projection(projection);

//var tip = d3.tip()
//  .attr('class', 'd3-tip')
//  .offset([-10, 0])
//  .html(function(d) {
//
//    d3.select(this).style("opacity",.3);
//    return "<strong>zipcode:</strong> <span style='color:red'>" + d.station + "</span>";
//        });
//
//dcmap.call(tip);

var opacity = d3.scale.linear().range([0.5,.9]);

var tooltip1 = d3.select("body").append("div")
    			 .attr("class", "tooltip")
   				 .style("opacity", 0.0);

var tooltip2 = d3.select("body").append("div")
    			 .attr("class", "tooltip")
   				 .style("opacity", 0.0);

var selectCircle0 = null;
var selectCircle1 = null;
var circleCount = 0;

d3.json("./data/dczipcode.geojson", function(error,dc){

        if (error) return console.error(error);
        console.log(dc);
//        console.log(topojson.feature(dc, dc.objects.dcZip));

//        console.log(topojson.feature(dc, dc.objects.dczipcode));
        dcmap.selectAll('path')
//            .data(topojson.feature(dc, dc.objects.dczipcode).features).enter().append('path')
            .data(dc.features).enter().append('path').attr("translate","transform(" + margin2.left + "," + (margin2.top + 200) +")")
            .attr("d", path).style("fill","rgb(192, 192, 192)").style({"stroke":"white","stroke-width":2});
//                .on("mouseover",
//                tip.show
//                function(d){
//                    console.log(tip.show);
//                    console.log(d);
//                    d3.select(this).style("fill","green")}
//                )
//                .on("mouseout",
//                tip.hide
//                    function(d){
//                    d3.select(this).style("fill","steelblue")}
//                );
        plotCircle();
//                function(d){ console.log(d); return "steeblue";});
    });
//initial the circle on the map

var circleData = null;
plotCircle.data = function(_){
        if (!arguments.length) {return linevalues0;}
        circleData= _;
        return plotCircle;
        };
function plotCircle(){

//    d3.csv("./data/bikeshare/bs_2012_11_01.csv",
    d3.csv(file,
        function(d){
                return {
                    "hour": +d.hour,
                    "net": +d.net,
                    "station": d.station,
                    "lat" : +d.lat,
                    "lon" : +d.lon,
                    "zipcode" : d.postal_code
                };
        },
        function(error,data) {

            console.log(error);
            console.log(file);

            var data_ = [];
            data.forEach(function (d) {
                if (d.hour === selectHour) {
                    data_.push(d);
                }
            });


            opacity.domain(d3.extent(data_.map(function (d) {
                return Math.abs(d.net);
            })));
//            console.log(opacity.domain());
//            console.log(opacity.range());
//            console.log(data_);

            dcmap.selectAll("circle")
                    .data(data_, function (d) {
                        return d.station;
                    })
                    .enter()
                    .append("circle")
                    .attr("class", "station")
                    .attr("r", 5)
                    .attr("cx", function (d, i) {return projection([d.lon, d.lat])[0];})
                    .attr("cy", function (d, i) {return projection([d.lon, d.lat])[1];})
                    .classed({"symbol": true})
                    .style("fill", function (d) {return fillcolor = (d.net < 0) ? "red" : "green";})
                    .style("opacity", function (d) {return opa = (d.net === 0) ? 0 : opacity(Math.abs(d.net));})
                    .on("mouseover", function (d) {
                        tooltip1.transition()
                                .duration(200)
                                .style("opacity", 1);
//                        console.log(d.station);
                        tooltip1.html("<strong>Station: </strong><span style='color:red'>" + d.station + "</span><br><strong>Net bikes number: </strong><span style='color:red'>" + d.net + "</span>")
                                .style("left", (event.pageX + 15) + "px")
                                .style("top", (event.pageY - 10) + "px");
//                    d3.select(this).style("stroke", "black");
                        d3.select(this).attr("r", 7);

                    })
                    .on("mouseout", function (d) {
                        tooltip1.transition()
                                .style("opacity", 0);
                        d3.select(this).attr("r", 5);
                    })
                    .on("click", function (d) {

                        updatelineChart(d.station, d.net);

                        if (circleCount % 2 === 0) {

                            if (selectCircle0 !== null) {
                                selectCircle0.style("stroke", "none");
                            }
                            selectCircle0 = d3.select(this);
                            selectCircle0.style({"stroke": "steelblue", "stroke-width": 3});
                        }
                        else {
                            if (selectCircle1 != null) {
                                selectCircle1.style("stroke", "none");
                            }
                            selectCircle1 = d3.select(this);
                            selectCircle1.style({"stroke": "black", "stroke-width": 3});
                        }
                        circleCount++;
                    });

        });

    console.log(file);
    function showHighlight(d) {
        // highlight symbol
        d3.select(this).style("stroke","black");
        console.log(d);}
    function hideHighlight(d) {
        // highlight symbol
        d3.select(this).style("stroke","none");}
    return plotCircle;
    }

plotCircle.update = function(_){

    console.log(circleData);
    console.log(d3.selectAll(".station"));
    var circles = d3.selectAll(".station").data(circleData, function(d){ return d.station}).transition().duration(1000).style("fill", function (d) {
                                return fillcolor = (d.net < 0) ? "red" : "green";
                            })
                            .style("opacity", function (d) {
                                return opa = (d.net === 0) ? 0 :opacity(Math.abs(d.net));
                            });

//    circles.exit().transition().duration(1000).remove();
//    circles.enter().append("circle")
//            .attr("class", "station")
//            .attr("r", 5)
//            .attr("cx", function (d, i) {return projection([d.lon, d.lat])[0];})
//            .attr("cy", function (d, i) {return projection([d.lon, d.lat])[1];})
//            .classed({"symbol": true})
//            .attr("id", function (d, i) {
//                        return "circle" + i;
//                    })
//            .style("fill", function (d) {return fillcolor = (d.net < 0) ? "red" : "green";})
//            .style("opacity", function (d) {return opa = (d.net === 0) ? 0 : opacity(Math.abs(d.net));})
//            .on("mouseover", function (d) {
//                tooltip1.transition().duration(200).style("opacity", 1);
//                        console.log(d.station);
//                tooltip1.html("<strong>Station: </strong><span style='color:red'>" + d.station + "</span><br><strong>Net bikes number: </strong><span style='color:red'>" + d.net + "</span>")
//                        .style("left", (event.pageX + 15) + "px")
//                        .style("top", (event.pageY - 10) + "px");
//
//                d3.select(this).attr("r", 7);
//            })
//            .on("mouseout", function (d) {
//                tooltip1.transition()
//                        .style("opacity", 0);
//                d3.select(this).attr("r", 5);
//            })
//            .on("click", function (d) {
//                updatelineChart(d.station, d.net);
//                if (circleCount % 2 === 0) {
//
//                    if (selectCircle0 !== null) {selectCircle0.style("stroke", "none");}
//                    selectCircle0 = d3.select(this);
//                    selectCircle0.style({"stroke": "black", "stroke-width": 2});
//                }
//                else {
//                    if (selectCircle1 != null) {selectCircle1.style("stroke", "none");}
//                    selectCircle1 = d3.select(this);
//                    selectCircle1.style({"stroke": "black", "stroke-width": 2});
//                }
//                circleCount++;
//                    });
//
//            });
};
plotCircle.update1 = function(_){

    // update color scale
    opacity.domain(d3.extent(circleData.map(function (d) {
                return Math.abs(d.net);
            })));
    console.log(circleData.length);
//    console.log(d3.selectAll(".station"));
    var circles = d3.selectAll(".station").data(circleData, function(d){ return d.station});

        circles.exit().transition().duration(1000).remove();

        circles.transition().duration(1000).style("fill", function (d) {
                                return fillcolor = (d.net < 0) ? "red" : "green";
                            })
                            .style("opacity", function (d) {
                                return opa = (d.net === 0) ? 0 :opacity(Math.abs(d.net));
                            });

//      circles.exit().transition().duration(1000).remove();
        circles.enter().append("circle")
            .attr("class", "station")
            .attr("r", 5)
            .attr("cx", function (d, i) {return projection([d.lon, d.lat])[0];})
            .attr("cy", function (d, i) {return projection([d.lon, d.lat])[1];})
            .classed({"symbol": true})
//            .attr("id", function (d, i) {
//                        return "circle" + i;
//                    })
            .style("fill", function (d) {return fillcolor = (d.net < 0) ? "red" : "green";})
            .style("opacity", function (d) {return opa = (d.net === 0) ? 0 : opacity(Math.abs(d.net));})
            .on("mouseover", function (d) {
                tooltip1.transition().duration(200).style("opacity", 1);
                        console.log(d.station);
                tooltip1.html("<strong>Station: </strong><span style='color:red'>" + d.station + "</span><br><strong>Net bikes number: </strong><span style='color:red'>" + d.net + "</span>")
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");

                d3.select(this).attr("r", 7);
            })
            .on("mouseout", function (d) {
                tooltip1.transition()
                        .style("opacity", 0);
                d3.select(this).attr("r", 5);
            })
            .on("click", function (d) {
                updatelineChart(d.station, d.net);
                if (circleCount % 2 === 0) {

                    if (selectCircle0 !== null) {selectCircle0.style("stroke", "none");}
                    selectCircle0 = d3.select(this);
                    selectCircle0.style({"stroke": "black", "stroke-width": 2});
                }
                else {
                    if (selectCircle1 != null) {selectCircle1.style("stroke", "none");}
                    selectCircle1 = d3.select(this);
                    selectCircle1.style({"stroke": "black", "stroke-width": 2});
                }
                circleCount++;
                    });

//            });
};
plotCircle.hover = function(zipcode){

    console.log(zipcode);
    d3.selectAll(".station").transition().duration(400).style("opacity", function (d) {return opa = (d.zipcode === zipcode) ? opacity(Math.abs(d.net)) : 0;})
};
plotCircle.hover_ = function(){

//    console.log("ffff");
    d3.selectAll(".station").transition().duration(400).style("opacity", function (d) {return opa = (d.net === 0) ? 0 : opacity(Math.abs(d.net));})
};




var framewidth = 1200,
    frameheight = 1200;

var margin1 = {"left":50,"top":50,"right":50,"bottom":50 };
var width1 = 400 - margin1.left - margin1.right,
        height1 = 560;

var svg = d3.select("#dashboard").append("svg").attr("width",framewidth).attr("height",frameheight);

var twoSidedBar = dashboard2.append("g").attr("transform","translate(" + (margin2.left + gridSize*12) + "," + margin2.top + ")");

var xScale = d3.scale.linear().range([0, width1]);
var xAxis = d3.svg.axis().scale(xScale).orient("top");

var yScale = d3.scale.ordinal().rangeBands([0, height1], .1, .5);
var yAxis = d3.svg.axis().scale(yScale).orient("left");

var bardata = null;
var nestedBarData = null;

function compare2(a,b) {
  if (+a.hour < +b.hour)
     return -1;
  if (+a.hour > +b.hour)
    return 1;
  return 0;
}

// initiate two sided barchart
d3.csv(file,

        function(d){
                return {
                    "hour": +d.hour,
                    "net": +d.net,
                    "station": d.station,
                    "zipcode": +d.postal_code
                };
        },
        function(error,data){

            console.log(error);


            var temp = d3.nest().key(function(d){return d.hour})
                    .key(function(d){return d.zipcode;}).sortKeys(d3.ascending)
                    .rollup(function(d){ return d3.sum(d, function(e){ return e.net;});}).entries(data);


            plotTwoSideBar.values(temp);
            plotTwoSideBar();
        });





function plotTwoSideBar(){

    var dataRange = [];
    bardata.forEach(function(d){d.values.forEach(function(e){ dataRange.push(e.values);});});
    xScale.domain(d3.extent(dataRange));
    yScale.domain( bardata[0].values.map(function (d) {return d.key;}));
    var data_ = [];
    bardata.forEach(function(d){
        if (+d.key === selectHour){
            d.values.forEach(function(e){ data_.push(e);});
        } });

    console.log(yScale.domain());
    console.log(data_);
    console.log(bardata);
    var xGuide = twoSidedBar.append("g").attr("class", "x axis").attr("id", "xAxis1").call(xAxis);
    var yGuide = twoSidedBar.append("g").attr("class", "y axis").attr("id", "yAxis1").call(yAxis);

    xGuide.selectAll('line').style({"fill": "none", "stroke": "black"});
    xGuide.selectAll('path').style({"fill": "none", "stroke": "black"});

    var xGuideText = xGuide.append("text").attr("transform","translate(" + width1/2 + ",0)").attr("y",-30).text("Bike Demand").style("text-anchor","middle");

    yGuide.selectAll('line').style({"fill": "none", "stroke": "black"});
    yGuide.selectAll('path').style({"fill": "none", "stroke": "black"});

    var yGuideText = yGuide.append("text").attr("y", -60).attr("x", -height1/2).attr("transform", "rotate(-90)").text("zipcode").style("text-anchor","middle");

    var grid = twoSidedBar.append("g");

    grid.append("line").attr("class","grid").attr("id","zeroGrid")
            .attr("x1", xScale(0))
            .attr("x2", xScale(0))
            .attr("y2", height1).style({"fill":"none","stroke":"black"});

    grid.selectAll(".grid").data(data_).enter().append("line")
            .attr("x1",0)
            .attr("y1",function(d){return yScale(d.key) - 0.05*yScale.rangeBand();})
            .attr("x2",width1)
            .attr("y2",function(d){return yScale(d.key) - 0.05*yScale.rangeBand();}).style({"fill":"none","stroke":"gray","stroke-width":0.5});


    var bars = twoSidedBar.selectAll(".bar").data(data_).enter().append('rect')
            .attr("class","bars")
            .attr("id", function(d,i){ return "bar" + d.key})
            .attr("x",  function(d){
                if(d.values>=0){return xScale(0);}
                else{ return xScale(d.values);}
            })
            .attr("y",  function(d){return yScale(d.key);})
            .attr("height", yScale.rangeBand())
            .attr("width", function(d){

                if(d.values>=0){return xScale(d.values) - xScale(0);}
                else{ return xScale(0) - xScale(d.values);}
            })
            .style("fill","steelblue")
            .on("mouseover", function(d) {

                tooltip2.transition().duration(200)
                        .style("opacity", 1);

                tooltip2.html("<strong>Demand: </strong><span style='color:red'>" + d.values + "</span>")
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                d3.select(this).style("opacity", 0.5);
//                console.log(d);
                plotCircle.hover(d.key);


            })
            .on("mouseout", function(d){

                tooltip2.transition().style("opacity", 0);
                d3.select(this).style("opacity", 1);
                plotCircle.hover_();
            });


}

plotTwoSideBar.values = function(_) {
        if (!arguments.length) {return bardata;}
        bardata = _;
        return plotTwoSideBar;
        };
plotTwoSideBar.update = function(_){
        if (!arguments.length) {return bardata;}

        // data transformation
        // select the data that corresponds to selected hour
        var data_ = [];
        bardata.forEach(function(d){
            if (+d.key === _ ){
                d.values.forEach(function(e){ data_.push(e);});
            } });

        // update the bar chart
        data_.forEach( function(d){

                var bar = "#bar" + d.key;

                d3.select(bar).datum(d).transition().duration(1000)
                    .attr("x", function(d){
                        if(d.values >=0 ){return xScale(0);}
                        else{return xScale(d.values);}})
                    .attr("width", function(d){
                        if(d.values >=0 ){return xScale(d.values)-xScale(0);}
                        else{return xScale(0)-xScale(d.values);}})
                });

        return plotTwoSideBar;
        };
plotTwoSideBar.updateAxis = function(){

    var dataRange = [];
    bardata.forEach(function(d){d.values.forEach(function(e){ dataRange.push(e.values);});});
    xScale.domain(d3.extent(dataRange));
    xAxis.scale(xScale);
    d3.select("#xAxis1").transition().duration(1000).call(xAxis);
    var xGuide_ = d3.select("#xAxis1");
    xGuide_.selectAll('line').style({"fill": "none", "stroke": "black"});
    xGuide_.selectAll('path').style({"fill": "none", "stroke": "black"});

    d3.select("#zeroGrid").transition().duration(1000)
            .attr("x1", xScale(0))
            .attr("x2", xScale(0));

//    yScale.domain( bardata[0].values.map(function (d) {return d.key;}));
//    console.log(yScale.domain().length);
//    yAxis.scale(yScale);
//    d3.select("#yAxis1").transition().duration(1000).call(yAxis);
};

function updateCal(file) {
    // read the new data from new file
    d3.csv(file,
            // parse the new data
            function (d) {
                return {
                    "hour": parseDate2(d.hour),
                    "net": +d.net,
                    "station": d.station,
                    "lat": +d.lat,
                    "lon": +d.lon,
                    "zipcode": d.postal_code
                };
            },
            // create data for barplot
            function (error, data) {

                // update two sided bar chart
                var temp = d3.nest().key(function (d) {return d.hour.getHours()})
                        .key(function (d) {return d.zipcode;}).sortKeys(d3.ascending)
                        .rollup(function (d) {return d3.sum(d, function (e) {return e.net;});
                        }).entries(data);

                // update bardata
                plotTwoSideBar.values(temp);
                plotTwoSideBar.updateAxis();
                console.log(selectHour);
                plotTwoSideBar.update(selectHour);

                //update linedata
                plotLineChart.data(data);
                plotLineChart.updateAxis();
                plotLineChart.update1();

                //update temperature
                plotTemperature.update();

                // update circles
                var data_ = [];
                data.forEach(function (d) {
                    if (d.hour.getHours() === selectHour) {
                        data_.push(d);
                    }
                });
                plotCircle.data(data_);
                plotCircle.update1();
            });
}
function updateClock(hour){

        d3.csv(file,
        function(d){
                return {
                    "hour": +d.hour,
                    "net": +d.net,
                    "station": d.station,
                    "lat" : +d.lat,
                    "lon" : +d.lon,
                    "zipcode" : d.postal_code
                };
        },
        function(error,data) {

//            console.log(data);
//            console.log(hour);


            // update two sided bar chart
            var temp = d3.nest().key(function(d){return d.hour})
                    .key(function(d){return d.zipcode;}).sortKeys(d3.ascending)
                    .rollup(function(d){ return d3.sum(d, function(e){ return e.net;});}).entries(data);

            //updae two-side barchart
            plotTwoSideBar.values(temp);
            plotTwoSideBar.update(hour);

            //update temperature
            plotTemperature.update();

            //update circle
            var data_ = [];
                data.forEach(function (d) {
                    if (d.hour === hour) {
                        data_.push(d);
                    }
                });
            plotCircle.data(data_);
            plotCircle.update();

                    });

}

selectTemp = null;
selectWeather = null;

var temperature = widget.append('g')
        .attr("transform","translate(0," + (radius*2 + gridSize*4) + ")");
var tempRect = temperature.append("rect")
        .attr("width",gridSize*7)
        .attr("height",temperatureHeight)
        .style("fill","none");
var temperatureData = null;


    d3.csv('./data/projectData.csv', function(d){
        return { "weather": +d.weather,
                "temp": +d.temp,
                "humidity": +d.humidity,
                "windspeed": +d.windspeed,
                "day" : +d.day,
                "hour" : +d.hour};
            }, function(error,data){

        data.forEach(function(d){

            if (d.hour === selectHour && d.day === selectDate){
                console.log(d);
                selectTemp = d.temp;
                console.log(d.weather);
                switch (d.weather){

                    case 1: selectWeather = "Clear, Partly Cloudy";
                        break;
                    case 2: selectWeather = "Mist, Cloudy";
                        break;
                    case 3: selectWeather = "Light Snow, Rain";
                        break;
                    case 4: selectWeather = "Heavy Rain, Thunderstorm";
                        break;
                    default: selectWeather = "";
                }
//                selectWeather = d.weather;
                console.log(selectWeather)
            }
        });
        var temp = d3.nest().key(function(d){return d.day}).sortKeys(d3.ascending)
                    .key(function(d){return d.hour;}).sortKeys(d3.ascending)
//                    .rollup(function(d){ return d3.sum(d, function(e){ return ;});})
                    .entries(data);

                console.log(temp);
        plotTemperature.data(temp);
        plotTemperature()
        }
    );

function plotTemperature(){

    temperature.append("text").attr("id","temperatureText").attr("transform","translate(0,45)").text(selectTemp+"˚C, ")
            .style({"font-family": "arial, sans-serif", "fill": "gray", "font-size": "24px", "font-weight": "bold"});
    temperature.append("text").attr("id","weatherText").attr("transform","translate(0,80)").text(selectWeather)
            .style({"font-family": "arial, sans-serif", "fill": "gray", "font-size": "24px", "font-weight": "bold"});
}
plotTemperature.data = function(_){
        if (!arguments.length) {return linevalues0;}
        temperatureData= _;
        return plotLineChart;
        };
plotTemperature.update = function(_){

    selectTemp = temperatureData[selectDate-1]["values"][selectHour]["values"][0]["temp"];
//    console.log(selectTemp);
    switch (temperatureData[selectDate-1]["values"][selectHour]["values"][0]["weather"]){

                    case 1: selectWeather = "Clear, Partly Cloudy";
                        break;
                    case 2: selectWeather = "Mist, Cloudy";
                        break;
                    case 3: selectWeather = "Light Snow, Rain";
                        break;
                    case 4: selectWeather = "Heavy Rain, Thunderstorm";
                        break;
                    default: selectWeather = "";
                }
//    console.log(selectWeather);
    d3.select("#temperatureText").transition().duration(1000).text(selectTemp+"˚C, ");
    d3.select("#weatherText").transition().duration(1000).text(selectWeather);
};

</script>
</div>
<style>

    #dashboard{
        height:50px;
        width:1000px;
    }
</style>
<div id = "dashboard" >
<div id = "report">
    <h2><b>Intro.</b></h2>
    <ul>
    Bike sharing systems have gained popularity over the past decade. Because of their accessibility and affordability,
    more than 500 bike sharing programs are running around the world to provide a low-cost alternative for short-term
    commutes and to help alleviate traffic. As bike sharing demands increase, unavailability and uneven distribution of
    bikes become a critical issue for the programs, which could undermine users’ experience and waste public resources.
    <br>
    This project implemented a dashboard using Javascript D3 library to provide interaction with the Bikeshare demand data,
    provided by Capital Bikeshare, the bikeshare service in Washington D.C. One of the most important goal of this project
    is to visualize the bike rental demands geographically and and how they vary overtime. The result of this project
    can serve as part of city mobility research and provides insights of how to make bikeshare service better and
    benefit more people's daily life.
    </ul>
    <h2><b>Techniques/Interactivity</b></h2>
    <ul>
    <h4><b>Calendar and Clock</b>:</h4>
        This two visualization encode time stamp information of the dataset and provide users accesses to select
        different part of the data set. For calendar map, each square represents a single day in November 2012.
        As for donut chart, each arch represents an hour in a given date. Because this visualization
        is not used for comparison or , I decided to use donut char
        I used color as pre-attentative attribute to indicate the data point that be selected so that users can
        easily refer.
    <h4><b>Symbol Map</b></h4>
        The symbol map is the most important part of this dashboard. It encodes stations latitude and longitude information
        with cir
    <h4><b>Two Sided barchart</b></h4>
        This visualization aims to provide bike demand information by region. I decide to use vertical two-sided
        barchart with value of bike demand as x-axis and zip code as y-axis. The barchart allows users to easily
        compare values of different regions with the least lie factor. However, the x scale might suffer from extreme
        values of few outliers, which could potentially decrease the data density and data-ink ratio of this
        visualization.
        <br>
        For the interactivity, I implemented a tooltip to indicate the exact bike demand. It would show up when
        the mouse hovers bars. At the same time, stations that are not in the selected region would be
        temporarily removed from the map to provide a focus on the geo-location context of each region. In addition,
        the bars width and the x axis would dynamically change according to the selected date and hour.


    <h4><b>Line Chart</b></h4>
        The purpose of this line chart is to display the distribution of bike rental demand of two selected stations at a given date.
        It provides the hourly demand stations and also allows easy comparisons between the distribution of
        two different stations. Because relatively small amount of data is presented here, I decide to spend less
        space for this visualization so the data-ink ratio and the data density won't be too low.
        <br>
        For the interactivity, I implemented a cursor for each time series. Also, when hover the region, the legend
        below would also display the actual number of bike demands.

    </ul>


    <h2><b>Feedback</b></h2>
    <ul>
        The feedback from the lab are super useful for improving my visualization and overall design.
        At the beginning, I planned to have my symbol map displaying regional demand by zip code and barchart to
        present individual demand of each station. It was not a good decision at all because my bar chart was below the
        dashboard so users have to scroll down to see it. In addition, It requires a fair large
        height for the svg elemnt to accommodate all the data, which makes it impossible to view the whole chart in one
        screen.
        <br>
        <br>
        Thanks to my classmates' suggestion, I interchanged the roles of my symbol map and barchart. I used symbol map
        to represent the detail information for each bike station and used the barchart to display the regional information.
        This modification results high data density, low lie factor, and high data-ink ratio for my symbol map.
        Also, I would be able to accommodate the bar chart in between the widget and symbol map because of a fixed and
        smaller number of variables at y-axis. After those big change, I ended up with a very compact and informative
        dashborad with all visualization in one screen.



        <br>
        <br>



    </ul>



    <h2><b>Challenges</b></h2>
    <ul>
        The biggest challenge of this project is to simultaneously perform multiple transition of symbol map, bar chart,
        and line chart when the calendar or the clock is clicked. I addressed this challenge with function objects and
        sets of associated object function. For instance, for each of my visualization, I define one function object to initiate
        the plot, one object function to update the underlying data attached with svg elements and another object function
        to manipulate the transition. Once each function object is well defined, I can easily handle the transition by
        simply calling their object function.
        <br>
        <br>
        In addition, number of station with observed records vary from day to day. For Nov. 1st, there might be 95 stations
        while for Nov. 2nd, there might be only 90 stations. To dynamically track which stations have records of a given
        date, I assigned a key function of station name in <i>data()</i>. It would authomatically subset my dataset into
        <b>enter, exit, and update</b>. With separated accesses of this three subsets, I can create
        new circles for <b>enter</b> data, update the color scale and opacity for <b>update</b> data, and remove the
        circles of <b>exit</b> data.
        <br>
        <br>
        There are few challenges that I did not address subject to the limited time frame. One is to substitute map
        projection with google map API which provides more context on the map and also allows dragging and zooming action
        on the map. Another one is to implement an adjustable div element for my line chart so when I clicked a button,
        the large div would either pop up from the right hand side or the bottom and provide a large space for displaying
        my line chart.
    </ul>

    <h2><b>Conclusion</b></h2>
</div>
</div>
</body>
</html>